{"version":3,"sources":["PathfindingVisualizer/Node/Node.js","algorithms/dijkstra.js","algorithms/astar.js","algorithms/dfs.js","PathfindingVisualizer/components/info.js","PathfindingVisualizer/PathfindingVisualizer.js","App.js","serviceWorker.js","index.js"],"names":["Node","this","props","col","isFinish","isStart","isWall","onMouseDown","onMouseEnter","onMouseUp","row","extraClassName","id","className","Component","dijkstra","grid","startNode","finishNode","visitedNodesInOrder","distance","unvisitedNodes","nodes","node","push","getAllNodes","length","sortNodesByDistance","closestNode","shift","Infinity","isVisited","updateUnvisitedNeighbors","sort","nodeA","nodeB","unvisitedNeighbors","neighbors","filter","neighbor","getUnvisitedNeighbors","previousNode","getNodesInShortestPathOrder","nodesInShortestPathOrder","currentNode","unshift","getNeighbors","isInList","list","inList","listItem","heuristic","nodeCol","nodeRow","endCol","endRow","xOne","xTwo","yOne","yTwo","Math","abs","Info","alg","PathfindingVisualizer","state","mouseIsPressed","selectedAlgorithm","algoHasRun","getInitialGrid","setState","newGrid","getNewGridWithWallToggled","i","setTimeout","animateShortestPath","document","getElementById","animate","endNode","openList","closedList","g","h","f","current_node","current_neighbors","successor_current_cost","console","log","astar","s","v","pop","dfs","visualizeDijkstra","visualizeAStar","visualizeDFS","onClick","runSelected","window","location","reload","selectA","selectDijkstra","selectDFS","map","rowIdx","key","nodeIdx","handleMouseDown","handleMouseEnter","handleMouseUp","currentRow","createNode","slice","newNode","App","Boolean","hostname","match","ReactDOM","render","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.1960665a.chunk.js","sourcesContent":["import React, { Component } from 'react';\n\nimport './Node.css';\n\nexport default class Node extends Component {\n  render() {\n    const {\n      col,\n      isFinish,\n      isStart,\n      isWall,\n      onMouseDown,\n      onMouseEnter,\n      onMouseUp,\n      row\n    } = this.props;\n    const extraClassName = isFinish\n      ? 'node-finish'\n      : isStart\n      ? 'node-start'\n      : isWall\n      ? 'node-wall'\n      : '';\n\n    return (\n      <div\n        id={`node-${row}-${col}`}\n        className={`node ${extraClassName}`}\n        onMouseDown={() => onMouseDown(row, col)}\n        onMouseEnter={() => onMouseEnter(row, col)}\n        onMouseUp={() => onMouseUp()}\n      ></div>\n    );\n  }\n}\n","// Performs Dijkstra's algorithm; returns *all* nodes in the order\n// in which they were visited. Also makes nodes point back to their\n// previous node, effectively allowing us to compute the shortest path\n// by backtracking from the finish node.\n\n// receives grid, start and finish from visualizeDijkstra function, returns visitedNodesInOrder\nexport function dijkstra(grid, startNode, finishNode) {\n  const visitedNodesInOrder = [];\n  startNode.distance = 0;\n  // single array of all nodes\n  const unvisitedNodes = getAllNodes(grid);\n  // while unvisited nodes remain, ... !![].length true if nonempty\n  while (!!unvisitedNodes.length) {\n    // sorts array of unvisited nodes by smallest to largest distance\n    sortNodesByDistance(unvisitedNodes);\n    // pop closest node off unvisited nodes. At first, closestNode is startNode, since dist is 0\n    const closestNode = unvisitedNodes.shift();\n    // If we encounter a wall, we skip it.\n    if (closestNode.isWall) continue;\n    // If the closest node is at a distance of infinity,\n    // we must be trapped and should therefore stop.\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\n    // Node becomes visited\n    closestNode.isVisited = true;\n    // pushes nodes in order algorithm sees them, starting with first node\n    visitedNodesInOrder.push(closestNode);\n    // if final node, return array of nodes visited in order\n    if (closestNode === finishNode) return visitedNodesInOrder;\n    // update unvisited neighbor nodes with distance of currentNode + 1\n    // ie on startNode, update surrounding 4 to distance of 1, then loop. Now there are 4 unvisited nodes with distance 1.\n    updateUnvisitedNeighbors(closestNode, grid);\n  }\n}\n\n// // sorts array of unvisited nodes by smallest to largest distance\nfunction sortNodesByDistance(unvisitedNodes) {\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n\nfunction updateUnvisitedNeighbors(node, grid) {\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n  // for every unvisited neighbor, update distance to 1 + current distance, and previous node to current node.\n  for (const neighbor of unvisitedNeighbors) {\n    neighbor.distance = node.distance + 1;\n    // this allows us to go back\n    neighbor.previousNode = node;\n  }\n}\n\n// returns a node's 4 neighbors\nfunction getUnvisitedNeighbors(node, grid) {\n  const neighbors = [];\n  // destructure col and row from node\n  const { col, row } = node;\n  // if below first row, add node above\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  // if above bottom row, add node below\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  // if to right of first column, add node to left\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  // add node to right\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  // of these neighbors, only return the unvisited ones\n  return neighbors.filter(neighbor => !neighbor.isVisited);\n}\n\n// return single array of all nodes, row by row\nfunction getAllNodes(grid) {\n  const nodes = [];\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n  return nodes;\n}\n\n// Backtracks from the finishNode to find the shortest path.\n// Only works when called *after* the dijkstra method above.\n\nexport function getNodesInShortestPathOrder(finishNode) {\n  const nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n  // until previousNode is null\n  while (currentNode !== null) {\n    // start end node, adds to array\n    nodesInShortestPathOrder.unshift(currentNode);\n    // switch to previousNode (defined in node object properties, initialized to null and assigned after algorithm)\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathOrder;\n}\n","export function astar(grid, startNode, endNode) {\n  const visitedNodesInOrder = [];\n  const openList = [];\n  const closedList = [];\n\n  startNode.g = 0;\n  startNode.h = heuristic(\n    startNode.col,\n    startNode.row,\n    endNode.col,\n    endNode.row\n  );\n  startNode.f = startNode.g + startNode.h;\n  openList.push(startNode);\n  while (!!openList.length) {\n    // Take from the open list current_node with lowest f value\n    sortNodesByF(openList);\n    const current_node = openList.shift();\n    if (current_node.isWall) {\n      continue;\n    }\n    // stuck case\n    if (current_node.g === Infinity) {\n      continue;\n    }\n    // for visualization\n    visitedNodesInOrder.push(current_node);\n    // success case, current_node is endNode\n    if (current_node === endNode) {\n      return visitedNodesInOrder;\n    }\n    // get current node's successors/nieghbors\n    const current_neighbors = getNeighbors(current_node, grid);\n    for (const neighbor of current_neighbors) {\n      // set neighbor current cost\n      const successor_current_cost = current_node.g + 1;\n      // if neighbor is in OPEN\n      if (isInList(neighbor, openList)) {\n        // if neighbor g <= successor_current_cost\n        if (neighbor.g <= successor_current_cost) {\n          // skips into next iteration of for loop (?)\n          continue;\n        }\n      } else if (isInList(neighbor, closedList)) {\n        if (neighbor.g <= successor_current_cost) {\n          continue;\n        }\n        // move neighbor from closed to open\n      } else {\n        openList.push(neighbor);\n        neighbor.h = heuristic(\n          neighbor.col,\n          neighbor.row,\n          endNode.col,\n          endNode.row\n        );\n      }\n      neighbor.g = successor_current_cost;\n      neighbor.f = neighbor.g + neighbor.h;\n      neighbor.previousNode = current_node;\n    }\n    closedList.push(current_node);\n  }\n  // error\n  console.log('algorithm failure');\n  return [];\n}\n\nfunction getNeighbors(node, grid) {\n  const neighbors = [];\n  // destructure col and row from node\n  const { col, row } = node;\n  // if below first row, add node above\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  // if above bottom row, add node below\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  // if to right of first column, add node to left\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  // add node to right\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  // of these neighbors, only return the unvisited ones\n  return neighbors;\n}\n\nfunction isInList(node, list) {\n  var inList = false;\n  for (const listItem of list) {\n    if (listItem.col === node.col && listItem.row === node.row) {\n      inList = true;\n    }\n  }\n  return inList;\n}\n\nfunction heuristic(nodeCol, nodeRow, endCol, endRow) {\n  let xOne = nodeRow;\n  let xTwo = endRow;\n  let yOne = nodeCol;\n  let yTwo = endCol;\n\n  let xChange = Math.abs(xTwo - xOne);\n  let yChange = Math.abs(yTwo - yOne);\n\n  return xChange + yChange;\n}\n\nfunction sortNodesByF(unvisitedNodes) {\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.f - nodeB.f);\n}\n","// void search(Node root) {\n//   if (root == null) return;\n//   visit(root);\n//   root.visited = true;\n//   for each (Node n in root.adjacent) {\n//     if (n.visited == false) {\n//       search(n);\n//     }\n//   }\n// }\n\nexport function dfs(grid, startNode, endNode) {\n  const visitedNodesInOrder = [];\n  const s = [];\n  s.push(startNode);\n\n  while (!!s.length) {\n    const v = s.pop();\n    if (v.isWall) {\n      continue;\n    }\n    if (v === endNode) {\n      return visitedNodesInOrder;\n    }\n    visitedNodesInOrder.push(v);\n    v.isVisited = true;\n    const neighbors = getNeighbors(v, grid);\n    for (const neighbor of neighbors) {\n      if (!neighbor.isVisited) {\n        neighbor.previousNode = v;\n        s.push(neighbor);\n      }\n    }\n  }\n  return [];\n}\n\nfunction getNeighbors(node, grid) {\n  const neighbors = [];\n  // destructure col and row from node\n  const { col, row } = node;\n  // if below first row, add node above\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  // if above bottom row, add node below\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  // if to right of first column, add node to left\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  // add node to right\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  // of these neighbors, only return the unvisited ones\n  return neighbors;\n}\n","import React from 'react';\n\nconst Info = (props) => {\n  if (props.alg === 'A*') {\n    return (\n      <div>\n        Informed search algorithm. Sorts partial solutions by minimizing\n        indiviudal node's f values, where f(n) = g(n) + h(n) combines distance\n        from start and a heuristic value, determined in this case by Manhattan\n        Distance or a node's distance from the finish node. Time complexity is\n        O(b^d), with b = branching factor, d = depth.\n      </div>\n    );\n  } else if (props.alg === 'dijkstra') {\n    return (\n      <div>\n        Similar to A* but does not use a heuristic function. Uses a data\n        structure for storing and querying partial solutions sorted only by\n        distance from the start. In some fields such as AI, Dijkstra's algorithm\n        is known as uniform cost search. Time complexity is O(|V| + |E|*log|V|),\n        with V = #nodes and E = #edges.\n      </div>\n    );\n  } else if (props.alg === 'DFS') {\n    return (\n      <div>\n        Depth First Search. Traverses each node until target is found. Less\n        efficient than an informed search such as A* or Dijkstra's\n      </div>\n    );\n  } else {\n    return (\n      <div>\n        click and drag to create walls, then select an algorithm and hit play\n      </div>\n    );\n  }\n};\n\nexport default Info;\n","import React, { Component } from 'react';\n// import code for individual node in grid\nimport Node from './Node/Node';\n// import algorithm code, and after algorithm runs return shortest path\nimport { dijkstra, getNodesInShortestPathOrder } from '../algorithms/dijkstra';\nimport { astar } from '../algorithms/astar';\nimport { dfs } from '../algorithms/dfs';\nimport Info from './components/info';\n\nimport './PathfindingVisualizer.css';\n\n// constants initializing start and end position\nconst START_NODE_ROW = 8;\nconst START_NODE_COL = 12;\nconst FINISH_NODE_ROW = 8;\nconst FINISH_NODE_COL = 34;\n\nexport default class PathfindingVisualizer extends Component {\n  constructor() {\n    super();\n    this.state = {\n      grid: [],\n      mouseIsPressed: false,\n      selectedAlgorithm: null,\n      algoHasRun: false,\n    };\n  }\n\n  // after component renders, setState grid -> getInitialGrid(), returned by getInitialGrid function\n  componentDidMount() {\n    const grid = getInitialGrid();\n    // state grid is an array of of javascript objects, not components. Components are rendered in render().\n    this.setState({ grid });\n  }\n\n  // ------- click and drag wall\n\n  // event of starting wall from click\n  handleMouseDown(row, col) {\n    // at position from argument, return a new grid with node at position updated\n    const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\n    // update state with new grid and mouseIsPressed= true\n    this.setState({ grid: newGrid, mouseIsPressed: true });\n  }\n\n  handleMouseEnter(row, col) {\n    if (!this.state.mouseIsPressed) return;\n    const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\n    this.setState({ grid: newGrid });\n  }\n\n  handleMouseUp() {\n    this.setState({ mouseIsPressed: false });\n  }\n\n  //  -----------\n\n  animate(visitedNodesInOrder, nodesInShortestPathOrder) {\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n      // if last node visited by path, animate shortest path\n      if (i === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          this.animateShortestPath(nodesInShortestPathOrder);\n        }, 25 * i);\n        return;\n      }\n      setTimeout(() => {\n        const node = visitedNodesInOrder[i];\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          'node node-visited';\n      }, 25 * i);\n    }\n  }\n\n  animateShortestPath(nodesInShortestPathOrder) {\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n      setTimeout(() => {\n        const node = nodesInShortestPathOrder[i];\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          'node node-shortest-path';\n      }, 50 * i);\n    }\n  }\n\n  // initiates solution when button is clicked\n  visualizeDijkstra() {\n    // grab grid from state\n    const { grid } = this.state;\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\n    // visitedNodes returned\n    const visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\n    // return shortest path\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n    //\n    this.animate(visitedNodesInOrder, nodesInShortestPathOrder);\n  }\n\n  visualizeAStar() {\n    const { grid } = this.state;\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\n    const visitedNodesInOrder = astar(grid, startNode, finishNode);\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n    this.animate(visitedNodesInOrder, nodesInShortestPathOrder);\n  }\n\n  visualizeDFS() {\n    const { grid } = this.state;\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\n    const visitedNodesInOrder = dfs(grid, startNode, finishNode);\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n    this.animate(visitedNodesInOrder, nodesInShortestPathOrder);\n  }\n\n  selectA() {\n    this.setState({ selectedAlgorithm: 'A*' });\n  }\n\n  selectDijkstra() {\n    this.setState({ selectedAlgorithm: 'dijkstra' });\n  }\n\n  selectDFS() {\n    this.setState({ selectedAlgorithm: 'DFS' });\n  }\n\n  runSelected() {\n    const { selectedAlgorithm, algoHasRun } = this.state;\n    if (!algoHasRun) {\n      if (selectedAlgorithm === 'dijkstra') {\n        this.visualizeDijkstra();\n      } else if (selectedAlgorithm === 'A*') {\n        this.visualizeAStar();\n      } else if (selectedAlgorithm === 'DFS') {\n        this.visualizeDFS();\n      }\n    }\n    this.setState({ algoHasRun: true });\n  }\n\n  render() {\n    // grab grid and mouseIsPressed from state\n    const { grid, mouseIsPressed, selectedAlgorithm } = this.state;\n\n    return (\n      <>\n        <div className=\"ui container\">\n          <h2 className=\"ui header custom-class\">\n            {selectedAlgorithm && (\n              <i className=\"play icon\" onClick={() => this.runSelected()}></i>\n            )}\n            <i\n              className=\"redo icon\"\n              onClick={() => window.location.reload(false)}\n            ></i>\n            <div className=\"content\">\n              Pathfinding Algorithm Visualizer\n              <div className=\"sub header\">Find the shortest path!</div>\n            </div>\n          </h2>\n          <div className=\"ui buttons\">\n            <button className=\"large ui button\" onClick={() => this.selectA()}>\n              A*\n            </button>\n            <button\n              className=\"large ui button\"\n              onClick={() => this.selectDijkstra()}\n            >\n              Dijkstra's\n            </button>\n            <button\n              className=\"large ui button\"\n              onClick={() => this.selectDFS()}\n            >\n              DFS\n            </button>\n          </div>\n          <div className=\"info-container\">\n            <Info alg={this.state.selectedAlgorithm}></Info>\n          </div>\n        </div>\n        {/*  --- grid --- */}\n        <div className=\"grid\">\n          {/* row is row itself, rowId is id of row */}\n          {grid.map((row, rowIdx) => {\n            return (\n              <div key={rowIdx}>\n                {row.map((node, nodeIdx) => {\n                  const { row, col, isFinish, isStart, isWall } = node;\n                  return (\n                    <Node\n                      key={nodeIdx}\n                      col={col}\n                      isFinish={isFinish}\n                      isStart={isStart}\n                      isWall={isWall}\n                      mouseIsPressed={mouseIsPressed}\n                      onMouseDown={(row, col) => this.handleMouseDown(row, col)}\n                      onMouseEnter={(row, col) =>\n                        this.handleMouseEnter(row, col)\n                      }\n                      onMouseUp={() => this.handleMouseUp()}\n                      row={row}\n                    ></Node>\n                  );\n                })}\n              </div>\n            );\n          })}\n        </div>\n        {/*  --- grid --- */}\n      </>\n    );\n  }\n}\n\n// called when component mounts. Creates first grid\nconst getInitialGrid = () => {\n  const grid = [];\n  for (let row = 0; row < 17; row++) {\n    const currentRow = [];\n    for (let col = 0; col < 46; col++) {\n      // create a node at x_11 .... x_1_50 and push it into currentRow.\n      currentRow.push(createNode(col, row));\n    }\n    grid.push(currentRow);\n  }\n  return grid;\n};\n\n// create individual nodes JS OBJECT PROPERTIES HERE\nconst createNode = (col, row) => {\n  return {\n    col,\n    row,\n    // if position matches start, this is true\n    isStart: row === START_NODE_ROW && col === START_NODE_COL,\n    // if \"\" finish, this is true\n    isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\n    distance: Infinity,\n    isVisited: false,\n    isWall: false,\n    previousNode: null,\n    // a* properties\n    g: Infinity,\n    h: Infinity,\n    f: Infinity,\n  };\n};\n\n// mark one position as walled\nconst getNewGridWithWallToggled = (grid, row, col) => {\n  // returns new grid object\n  const newGrid = grid.slice();\n  // find position indicated by arguments, grab that node [node object at that position]\n  const node = newGrid[row][col];\n  // create new Node with property isWall: true\n  const newNode = {\n    ...node,\n    // !node.isWall -> node.isWall = true\n    isWall: !node.isWall,\n  };\n  // update node at position to newNode within new Grid object\n  newGrid[row][col] = newNode;\n  // return new Grid object\n  return newGrid;\n};\n","import React from 'react';\nimport './App.css';\nimport PathfindingVisualizer from './PathfindingVisualizer/PathfindingVisualizer';\n\n// render the PathfindingVisualizer component\nfunction App() {\n  return (\n    <div className=\"App\">\n      <PathfindingVisualizer></PathfindingVisualizer>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}